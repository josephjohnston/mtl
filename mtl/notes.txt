
I guess we should be building a DLS, something that makes it not so verbose, and also that forces an understanding. 
we were thinking to have a DSL for low level proofs. 
would these be two separate layers?

Maybe what we want is a layered dsl that can build upon itself. so we can use this at the lowest and highest levels. 
recall our goal to begin with GPU was to figure out base level capabilities. 

i guess one way is to simplify the notation, not the semantics. 

maybe we should begin frameing around the worklow.
what can we create and how can we configure it, most importantly in what order with what dependencies? 
we can start with the device. we create a command queue. i think only one. 

we need to figure out where the separations are. of course all is interdependent, but we can create in a certain order. 
let's go through what we've already covered. 

for both debuggability and performance it would make sense to do all the customization on our side and send and few and as detailed as needed messages to the other side. 


Grand scheme:
create a device, and query it. use newCommandQueueWithMaxCommandBufferCount
create a command queue. (has label and device)
use command queue to create command buffer, there's a single one to do this: commandBufferWithDescriptor, though its only from iOS 14.0+. 
command buffer descriptor: create a new one and set the unretained references and errorOptions.
with this we have a command buffer. note we can create many. 
we'll enqueue the buffers in any order needed, and then customize and commit them. 
1. register state changes: scheduled and completed event handlers
2. submitting a command buffer: enqueue and commit
3. (N/A) waiting for state changes
4. (N/A) presenting a drawable
5. synchronize passes with events (only when don't have abn active encoder) (can also use shared events)
    can use shared events to do so across multiple devices, or use a a regular event to do so across multiple command queues for the same device. 
    create an event from a device
6. troubleshooting
check the status
check retained references (shouldn't need to as was set in descriptor)
identify using label, device, command_queue (hopefully we can get these things without messaging)
push and pop debug groups
check error
    if errorOption is EncoderExecutionStatus then the userInfo dictionary of this NSError yields CommandBufferEncoderInfo instance with the CommandBufferEncoderInfoErrorKey.
    i guess the CommandBufferEncoderInfo reflects the comands within the single encoder where the error occured
check errorOption (shouldn't need to as was set in descriptor)
check logs
check kernel times and execution times

CommandBufferError. where is this used?
maybe some code field of the command buffer's error field is set here. 
indeed, an NSError has code, domain, and userInfo.

I'm still confused between a command buffer's push/pop debug groups, and CommandBufferEncoderInfo debugSignposts. 
the signposts are the debug signposts from a single pass
whereas the debug groups seems to be maybe across encoders, and they show in the Frame Capture.
I see no mention of relationship between the two. 
debug groups have two sides. signposts dont. 
encoders have both of them. here with command buffers we only have the debug groups. the signposts of the CommandBufferEncoderInfo are those inserted by the command encoder. 
now the encoder and the command buffer have their own debug groups. 

when do we know if an error occured? by the status. but when do we know to check that? I guess whenever stuff does work, in worst case we go through every command buffer in the queue checking it's status. 

note if we can make it declarative then we can handle the ordering of all calls, holding responsibility for most errors ourselves. 

maybe we want a DSL in another language that we parse. no performance cost. 

this basically covers command buffers.
we create them, register handlers, submit, synchronize, and troubleshoot.

-----------------------------------

we want as few api calls as possible. not just for performance, but for debugging. 

Encoders and Passes

encoders (like command buffers) are transient
compute states are not transient 

i guess we must recreate an encoder for every use case, though we may reuse arguments we pass it. therefore, as it's transient, we can really think of it in terms of its arguments. 
and I think there's a single pipeline state for each encoder. but these are not transient. 

in grand scheme I guess we have devices, with queues, and each queue executes a series passes, but this series is broken into blocks via command buffers. one reason is to encode them in parallel. another I guess is to switch the parameters of the command buffer.
we should probably merge the transient encoder with non-transient state. 
so configuring a pass will mean specifying the pipeline and also the resources.

we already have the parts of the parent command encoder.
now for specific encoders.

pass descriptor
command encoder
    

pipeline descriptor
pipeline state


pipeline states are created with the device.

we need to start thinking about the declarative API


TODO

settle the label, device, etc.

switch to u64











we create a device.
from the device we create pipeline states. 


