

\section{Scalar Data Types}
u suffix for unsigned
i suffix for signed

bool
int8_t
uint8_t
int16_t
uint16_t
int32_t
uint32_t
int64_t
uint64_t
half, suffix h
float, suffix f
size_t = uint64_t
ptrdiff_t = int64_t
void

alignment:
1 for bool, 1 byte ints
2 for 2 byte ints
4 for 4 byte ints
8 for 8 byte ints
2 for 2 byte floats
4 for 4 byte floats

\section{Vector Data Types}

booln
charn
shortn
intn
longn
ucharn
ushortn
uintn
ulongn
halfn
floatn

vec<T, n>, T a scalar type, n = 2,3,4

for all these alignment still matches size

to access use brackets [] or use .xyzw
can use component notation for permutation, replication, assignment without duplicates

can't reference or point to a vector with swizzles.

constructors

packed vectors

\section{Matrix Data Types}

halfnxm
floatnxm
n,m = 2,3,4
made of n vectors of length m, ie column vectors. this is how you index into them.
constructors can use scalars or vectors

\section{SIMD-group Matrix Data Types}

simdgroup_half8x8
simdgoup_float8x8

\section{Alignment of Data Types}

alignas specifies alignment for type or object or var declaration or struct member, etc.
assume that pointers to a type point to an instance aligned as specified by the type.

\section{Atomic Data Types}

atomic<T>, T = int, uint, bool, ulong, float
aliases atomic_T
atomic functions can only use atomic data types

\section{Pixel Data Types}


\section{Buffers}

pointer to built in or user defined data type in device, constant, or threadgroup space.
can contain scalars, vectors, matrices, arrays of buffers, structures of buffers, unions of buffers.

\section{Textures}

enum class access { sample, read, write, read_write, };
texture#d_?array<T, access>, T = half, float, short, ushort, int, uint (I thought there were a lot more types)
it's a 'handle', cuz reading and writing happens indirectly.
texture declared inside a function must have access sample or read.

texture buffers are optimized for type conversion of pixel data
    unoptimized solutions including reading pixel data and doing conversion manually, or wrapping a buffer in a texture
opaque type is texture_buffer<T, access>, T = half, float, short, ushort, int, uint, (no sample access), usable like a regular texture
out of bounds write is ignored but may have performance penalty.
max width of a regular 1d texture is 16384. texture buffer can support more data.
one way to use is encode a large texture buffer in one form, then parts in many different forms in the shader, each one as if a different texture. 

\section{Samplers}
\section{Imageblocks}

\section{Aggregate Types}

arrays, structures, classes, unions
stucture members with address specifier can only be pointers. all members must be in same address space.

\subsection{Arrays}
textures and texture buffers (and samplers)
textures:
(const) array<typename T, size_t N>, T a texture type with access read or write or sample. 
texture buffers:
array<texture_buffer<T>, size_t N>

can pass as arg or declare as local var
can't have arrays in structures unless in an arg buffer

array_ref<T>, T sampler, texture, or texture buffer type
immutable
storage not owned by the array_ref object.
good for passing arrays of textures to user functions, not allowed to graphics or kernel functions, nor used as local var.

access with []
count with size()

page 45, constructors

\subsection{Structures}

passed to functions by value.
members buffers, textures, or samplers only. members can have attributes to specify location.

\section{Argument Buffers}

these buffers can contain pointers, textures, texture buffers, and samplers in addition to regular types.

\section{Uniform Type}

in header_uniform there's template class `uniform', only for bool, integer, floating point, and vectors. 
uniform<int> i = ..;
can't have a uniform pointer, but can point to a uniform value. 

\section{Visible Function Table}

header <metal_visible_function_table>
visible_function_table<typename T> type represents a table of function pointers to visible functions with T the signatures(?) of the functions.
opaque, can't be modified by GPU.
can be used in an arg buffer or passed to a qualified function with buffer binding.
eg
    for "[[visible]] int func(float f)", use visible_function_table<int(float)> functions;
    using fnptr = T (*)(..) [[visible]]
    fnptr operator[](uint index) const;
size() and empty()
so it seems a table is meant to hold many functions of the same signature. 

\section{Function Group Attribute}
[[function_group("group1","group2",..)]]
indicate groups of functions for indirect call through function pointer or visible_function_table.
args are strings literals to the attribute.

*fnptr[3] is a function
fnptr[3] is 3 pointers a functions, so *fnptr[3] is 3 functions.
*fnptr is a function so *fnptr[3] is 3 functions.

\section{Ray Tracing Types}
\section{Mesh Shader Types}

\section{Type Conversions and Re-interpreting Data}
static_cast for scalar to scalar with default rounding
as_type<type-id> converts i think similarly but no modification, must be of same size. it's bit reinterpretation. eg uint u = as_type<uint>(1.0)

\section{Implicit Type Conversions}

for scalar to scalar not just re-interpretation but conversion
for vector to * not allowed.
scalar to vector allowed. 


